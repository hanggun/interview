### 阿里9.29笔试</br>
参考自https://es2q.com/blog/2010/09/29/alibaba-coding-test202009/

#### 第一题

给出一个只有0和1的字符串，需要把该字符串划分为n段，且每段有且仅能有1个0</br>
第一个输入为字符串长度，第二行输入是字符串</br>
输出划分方案数，并对1e+9+7取模

样例：
```
5
010100
```
输出：
```
4
```
解决该题的思路是每次将字符串到第一个'0'为止的部分看为一个整体，在遇到第二个'0'之前，统计'1'的个数，到第二个'0'的总分割数就等于到第一个0为止的总分割数乘以到第二个'0'之前'1'的个数+1，若字符串全为1，则输出0</br>
令第一个'0'之前的总分割数为n,第一个'0'与第二个'0'之间'1'的个数为m,到第二个'0'为止的总分割数为k,则表达式为`k = n * (m+1)`

以010100为例，将第一个'0'看为一个整体，并且总分割数仅有1。到第二个'0'之间有一个'1'，那么'010'字符串可以分割为'0)10'和'01)0'，到第二个'0'为止，总分割数为`(1+1)*1=2`。接着将'010'看成一个整体，到第三个0之前有一个'1'，那么'01010'可以分割为'0101)0'和'010)10)'，所以到第三个0为止的总分割数为`(1+1)*2=4`，第四个'0'之前没有1，因此没有增加新的分割数。

代码为
```python
n = int(input())
l = input()

c = 0
i = 0
ans = 1
while i < len(l) and l[i] == '1':
    i += 1
if len(l) == i:
    print(0)
else:
    while i < len(l):
        if l[i] == '1':
            c += 1
        elif l[i] == '0':
            if c > 0:
                ans = (ans * (c + 1)) % 1000000007
                c = 0
        i += 1
    print(ans)
```

#### 第二题
一个英文联想输入法，词典有 n 个词。

输入时有两个方法：
>1. 输入一个字母，消耗 1 个时间
>2. 从词典中所有前缀为当前已输入字符的词，替换当前内容。耗时为当前匹配的所有词语的个数。即如果当前输入的字符有 m 个匹配，消耗 m 时间。
在给定字典的情况下，判断要输入的 q 个单词，每个单词最短耗时。

所有词长度不大于 10^6。

样例：
```
5 5
a
an
at
and
nowcoder
a
and
nowcoder
nowcoderovo
what
```
输出
```
1
3
2
5
4
```

本题的解题思路在于创建一个字典树，记录下每一个前缀的出现次数，还要记录该前缀是否为单词。创建完字典树之后，对需要查询的单词进行判断。查询单词是否在字典中的方法：从第一个字母开始遍历，若有一个字母不在字典中，则返回False，当搜索到字符串最后一个字母时，返回'f'值。为若单词存在于字典中，则从单词的第一个字母开始，比较输入字母时间（个数）加匹配时间（个数）与字母总体长度，返回最短查询时间。若单词不存在于字典中，记录下存在于字典中的前缀的最短查询时间，比较前缀最短时间加后续字母个数与总体字母个数之间的查询时间，返回最短查询时间。

以例子为例，当我们创建完字典后，我们会得到字典`tt['ch']['a']={'ch':{...}, 'f':True, 'c':4}`，代表以'a'为前缀的单词个数有4，并且有以'a'为前缀的单词，`tt['ch']['a']['n']={'ch:{}, 'f':True, 'c':2}`，代表以'an'为前缀的个数有2个，并且有以'an'为前缀的单词。当我们查询'an'时，通过查询字典可知，单词存在于字典中，因此只输入'a'时，最短查询时间为`min{2, 1+4}`，输入'an'时，最短查询时间为min{2, 2+2}

代码
```python
m,q = map(int, input().split())
tt = {'ch':{}, 'f':False, 'c':0}

def add_word(w, t, i):
    
    if i == len(w):
        t['f'] = True
        t['c'] += 1
        return
    
    t['c'] += 1
    if w[i] not in t['ch']:
        t['ch'][w[i]] = {'ch':{}, 'f':False, 'c':0}
    
    add_word(w, t['ch'][w[i]], i+1)
    
for _ in range(m):
    add_word(input(), tt, 0)
    
max_pos = [0]
def in_word(w):
    t = tt
    for i in range(len(w)+1):
        
        max_pos[0] = i
        
        if i == len(w):
            return t['f']
        
        if w[i] not in t['ch']:
            return False
        
        t = t['ch'][w[i]]
        
        
    
def count_ans(w):
    minc = len(w)
    t = tt
    for i in range(len(w)):
        
        if w[i] not in t['ch']:
            break
        
        t = t['ch'][w[i]]
        minc =min(minc, i+t['c']+1)
        
    return minc

for _ in range(q):
    w = input()
    if in_word(w):
        print(count_ans(w))
    else:
        x1 = count_ans(w[:max_pos[0]])
        print(min(x1 + len(w) - max_pos[0], len(w)))
```
